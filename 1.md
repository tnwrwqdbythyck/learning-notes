### Promise的含义
1. `Promise` 简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，`Promise` 是一个对象，从它可以获取异步操作的消息。
  - 对象的状态不受外界影响。`Promise` 对象代表一个异步操作，有三种状态：`pending(进行中)`、`fulfilled(已成功)`和`rejected(已失败)`。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
  - 一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise` 对象的状态改变，只有俩种可能：从 `pending` 变为 `fulfilled` 和从 `pending` 变为 `rejected`。只要这俩种情况发生，状态就凝固了，不会在变了，会一直保持这个结果，这个就称为 `resolved(已定型)`。如果改变已经发生了，你再对 `Promise` 对象添加回调函数，也会立即得到这个结果。这与事件`(Event)`完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。    
  - 有了 `Promise` 对象，就可以将异步操作以同步操作的流程表达出来，避免了层次嵌套的回调函数。此外，`Promise` 对象提供统一的接口，使得控制异步操作更加容易。
  - `Promise` 也有一些缺点。首先，无法取消 `Promise`，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，`Promise`内部抛出错误，不会反应到外部。第三，当处于 pending 状态是，无法得知当前进展到哪一个阶段（刚刚开始还是即将完成）。    
**如果某些事件不断地反复发生，一般来说，使用 `Stream` 模式是比部署`Promise`更好的选择。**
### 基本用法
ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。
```
const promise = new Promise(function(resolve,reject){
  //... some code
  if(/* 异步操作成功 */){
    resolve(value);
  }else {
    reject(error);
  }
});
```
&nbsp;&nbsp;&nbsp;&nbsp;Promise 构造函数接受一个函数作为参数，该函数的来个参数分别是resolve和reject。它们是俩个函数，有 JavaScript 引擎提供，不用自己部署。
resolve 函数的作用是，将 Promise对象从”未完成“变为”成功“（即从pending变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject 函数的作用是，将 Promise 对象的状态从”未完成“变为”失败“（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。     
&nbsp;&nbsp;&nbsp;&nbsp;Promise 实例生成以后，可以用then 方法分别指定 resolved状态和rejected状态的回调函数。
```
promise.then(function(value)){
  // success
},function(error){
  //failure
});
```
&nbsp;&nbsp;&nbsp;&nbsp;then方法接受俩个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise 独享的状态变为rejected时调用。其中，第二个函数是可选的，不一定提供。这俩个函数都接受Promise 对象传出值作为参数。
```
function timeout(ms){
  return new Promise((resolve,reject)=>{
    setTimeout(resolve,ms,"done");
  });
}

timeout(5000).then((value)=>{
  console.log(value);
});
```
&nbsp;&nbsp;&nbsp;&nbsp;上面代码中，timeout 方法返回一个Promise 实例，表示一段时间以后才会发生的结果。过来指定的时间（ms参数）以后，Promise 实例的状态变为resolved，就会触发then方法绑定的回调函数。    
&nbsp;&nbsp;&nbsp;&nbsp;Promise 新建后就会立即执行。
```
let promise = new Promise(function(resolve, reject) {
  console.log('Promise');
  resolve();
});

promise.then(function() {
  console.log('resolved.');
});

console.log('Hi!');

// Promise
// Hi!
// resolved
```
&nbsp;&nbsp;&nbsp;&nbsp;上面代码中，Promise 新建会立即执行，所以输出的是 Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。     
    
&nbsp;&nbsp;&nbsp;&nbsp;下面是异步加载图片的例子。
```
function loadImageAsync(url) {
  return new Promise(function(resolve, reject) {
    const image = new Image();

    image.onload = function() {
      resolve(image);
    };

    image.onerror = function() {
      reject(new Error('Could not load image at ' + url));
    };

    image.src = url;
  });
}
```
&nbsp;&nbsp;&nbsp;&nbsp;上面代码中，使用Promise 包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。    
    
&nbsp;&nbsp;&nbsp;&nbsp;下面是一个用Promise对象实现Ajax操作的例子(未测试通过)。
```
const getJSON = function(url) {
  const promise = new Promise(function(resolve, reject){
    const handler = function() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    const client = new XMLHttpRequest();
    client.open("GET", url);
    client.onreadystatechange = handler;
    client.responseType = "json";
    client.setRequestHeader("Accept", "application/json");
    client.send();

  });

  return promise;
};

getJSON("/posts.json").then(function(json) {
  console.log('Contents: ' + json);
}, function(error) {
  console.error('出错了', error);
});
```
&nbsp;&nbsp;&nbsp;&nbsp;上面代码中，getJson 是对XMLHTTPRequest对象的封装，用于发出一个针对JSON数据的HTTP请求，并且放回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。    
&nbsp;&nbsp;&nbsp;&nbsp;如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve 函数的参数除了正常的值以外，还可能是另一个Promise实例
```
const p1 = new Promise(function (resolve, reject) {
  // ...
});

const p2 = new Promise(function (resolve, reject) {
  // ...
  resolve(p1);
})
```
&nbsp;&nbsp;&nbsp;&nbsp; 上面代码中，p1和p2 都是Promise的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果返回另一个异步操作。
&nbsp;&nbsp;&nbsp;&nbsp; 至于，这是p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数就会立即执行。
```
const p1 = new Promise(function (resolve, reject) {
  setTimeout(() => reject(new Error('fail')), 3000)
})

const p2 = new Promise(function (resolve, reject) {
  setTimeout(() => resolve(p1), 1000)
})

p2
  .then(result => console.log(result))
  .catch(error => console.log(error))
// Error: fail
```
&nbsp;&nbsp;&nbsp;&nbsp;上面代码中,p1是一个Promise,3秒之后变为rejected。p2的状态在1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected,导致catch方法指定的回调函数。    
**注意，调用resolve或reject并不会终结Promise的参数函数的执行。**
```
new Promise((resolve, reject) => {
  resolve(1);
  console.log(2);
}).then(r => {
  console.log(r);
});
// 2
// 1
```
&nbsp;&nbsp;&nbsp;&nbsp;上面代码中调用resolve或reject以后，Promise的使命就完成了，后继操作应该放在then方法里面，而不应该直接写在resolve或reject后面。所以最好在它们前面加上return语句，这样就不会有意外。
```
new Promise((resolve, reject) => {
  return resolve(1);
  // 后面的语句不会执行
  console.log(2);
})
```
### Promise.prototype.then()
&nbsp;&nbsp;&nbsp;&nbsp;`Promise`实例具有`then`方法，也就是说，`then`方法是定义在原型对象`Promise.prototype()`上的。它的作用是为`Promise`实例添加状态改变时的回调函数。前面说过，`then`方法的第一个参数是`resolved`状态的回调函数，第二个参数（可选）是`rejected`状态的回调函数。
&nbsp;&nbsp;&nbsp;&nbsp;`then`方法返回的是一个新的`Promise`实例（注意，不是原来那个`Promise`实例）。因此可以采用链式写法，即`then`方法后面再调用then方法。
```
getJSON("/posts.json").then(function(json) {
  return json.post;
}).then(function(post) {
  // ...
});
```
&nbsp;&nbsp;&nbsp;&nbsp;上面的代码使用`then`方法，依次指定了俩个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。
&nbsp;&nbsp;&nbsp;&nbsp;采用链式的`then`,可以指定一组按照次序调用的回调函数。这是，前一个回调函数，有可能返回的还是一个`Promise`对象（即有异步操作），这是后一个回调函数就会等待该`Promise`对象的状态发生变化，才会被调用。
```
getJSON("/post/1.json").then(function(post) {
  return getJSON(post.commentURL);
}).then(function funcA(comments) {
  console.log("resolved: ", comments);
}, function funcB(err){
  console.log("rejected: ", err);
});
```
&nbsp;&nbsp;&nbsp;&nbsp;上面代码中，第一个`then`方法指定的回调函数，返回的是另一个`Promise`对象。这时第二个`then`方法指定的回调函数，就会等待这个新的`Promise`对象状态发生变化。如果变为`resolved`，就调用`funcA`，如果状态变为`rejected`，就调用`funcB`。如果采用箭头函数，上面的代码可以写的更简洁。
```
getJSON("/post/1.json").then(
  post => getJSON(post.commentURL)
).then(
  comments => console.log("resolved: ", comments),
  err => console.log("rejected: ", err)
);
```
### Promise.prototype.catch()
&nbsp;&nbsp;&nbsp;&nbsp;Promise.prototype.catch()方法是.then(null,rejection)的别名，用于指定发生错误时的回调函数。
```
getJSON('/posts.json').then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log('发生错误！', error);
});
```
&nbsp;&nbsp;&nbsp;&nbsp;上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为resolved,则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，则会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。
```
p.then((val) => console.log('fulfilled:', val))
  .catch((err) => console.log('rejected', err));

// 等同于
p.then((val) => console.log('fulfilled:', val))
  .then(null, (err) => console.log("rejected:", err));
```
&nbsp;&nbsp;&nbsp;&nbsp;下面是一个例子。
```
const promise = new Promise(function(resolve, reject) {
  throw new Error('test');
});
promise.catch(function(error) {
  console.log(error);
});
// Error: test
```
&nbsp;&nbsp;&nbsp;&nbsp;上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。注意，上面的写法与下面俩种写法是等价的。
```
// 写法一
const promise = new Promise(function(resolve, reject) {
  try {
    throw new Error('test');
  } catch(e) {
    reject(e);
  }
});
promise.catch(function(error) {
  console.log(error);
});

// 写法二
const promise = new Promise(function(resolve, reject) {
  reject(new Error('test'));
});
promise.catch(function(error) {
  console.log(error);
});
```
&nbsp;&nbsp;&nbsp;&nbsp;比较上面俩种写法，可以发现reject方法的作用，等同于抛出错误。    
&nbsp;&nbsp;&nbsp;&nbsp;如果Promise状态已经变味resolved，在抛出错误是无效的。
```
const promise = new Promise(function(resolve, reject) {
  resolve('ok');
  throw new Error('test');
});
promise
  .then(function(value) { console.log(value) })
  .catch(function(error) { console.log(error) });
// ok
```
&nbsp;&nbsp;&nbsp;&nbsp;上面代码中，Promise在resolve语句后面，在抛出错误，不会被捕获，等于没有抛出。因为Promise的状态一旦干煸，就永久保持该状态，不会再变了。    
&nbsp;&nbsp;&nbsp;&nbsp;Promise 对象的错误具有'冒泡'性质，会一直向后传递，直到被捕获为止。也就是说错误总是会被下一个catch语句捕获。
```
getJSON('/post/1.json').then(function(post) {
  return getJSON(post.commentURL);
}).then(function(comments) {
  // some code
}).catch(function(error) {
  // 处理前面三个Promise产生的错误
});
```
